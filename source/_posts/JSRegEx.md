---
title: 'JSRegEx '
date: 2020-08-14 16:06:49
tags: JavaScript
---

### Regular Expressions:

**a sequence of characters that define a search pattern in a search pattern for text**

##### 两种字符：

**1.literal character： 表示某个特定的字符**

**2.Meta character： 表示某一类型的字符**

**选择符：   a|@     查询a或者@**

**原子组： **

```javascript
/010\-\d{7,8}|020\-\d{7,8}/   ==   /(010|020)\-\d{7,8}/    用括号包裹起来的部分就是原子组
```

**原子表:**

```javascript
/[1234]/  表示1或2或3或4
/[^1234]/ 表示除了1，2，3，4都要
/[\d\D]+/ 利用原子表巧妙匹配所有字符
```

**+： 表示一个或多个    *：表示0个或多个**

```javascript
/\d+/ 表示一个或多个数字
```

##### .   表示除换行外任何字符/表示普通点 . 

```javascript
let price = '12:32'
 let reg = /\d+.\d+/
 console.log(reg.test(price)); -->true 因为这里的.意思是除换行符以外的任何字符

let reg = /\d+\.\d+/

false --> 因为这里的.表示字符'.'
```

**？表示有或没有都可以**

```javascript
/https?/-->http/https
```

**正则匹配中文：**

```javascript
str.match(/\p{sc=Han}/gu )   匹配出str中的所有中文
```

**正则匹配乱码：**

u模式解决



#### 创建正则表达式的方式

##### 1:字面量法：

let reg = /\d/

**局限：难以传入变量**

##### 字面量转义：

**d代表字母d     \d代表所有数字   \D除了数字   \s 表示空白（空格或换行符）\w: 字母数字下划线  **  



##### 2:对象创建：

let reg = new RegExp('\d',g) ---->第一个参数是查询语句，第二个是模式

##### 对象转义：

**在字符串中，'d'=='d', 'd' == '\d' **

**所以在对象创建法中，由于第一个参数是一个字符串，需要转义两次**

```javascript
/\d/   == new RegExp('\\d')
```

##### **lastIndex属性:**

**g模式** 在多次匹配的正则中，我们会丢失正则匹配的完整信息。但是如果我们利用正则表达式 reg.exec()操作（全局模型之下，非全局模式永远是0），他不会立马返回全局信息，而是将reg中的lastIndex属性加一，每一次匹配下一个信息。这个属性不会因为字符串的替换而自动置0，也就意味着执行的次数会影响下一个用exec方法的字符串。操作完一个字符串，lastIndex会变成null然后再置0

**y模式** 会在检索失败后直接将lastIndex置0而不是像g一样跳过匹配不上的项去检索下一项



#### 正则模式：

##### s:将字符串看成单行/将换行符看成普通空格

**i:不区分大小写**

**g:全局搜索，而不是匹配到一个就停**

**m:多行匹配，以换行符为开始新的匹配的标识**

**y: **